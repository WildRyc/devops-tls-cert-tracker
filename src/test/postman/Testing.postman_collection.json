{
	"info": {
		"_postman_id": "ee8d884a-b821-4ba3-a68f-4b805c9f3435",
		"name": "Testing",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "28751556",
		"_collection_link": "https://lively-water-583688.postman.co/workspace/Team-Workspace~00f3b9a7-2cfc-4e48-879e-5ff85d9ebec0/collection/28751556-ee8d884a-b821-4ba3-a68f-4b805c9f3435?action=share&source=collection_link&creator=28751556"
	},
	"item": [
		{
			"name": "Get All Certs",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status test 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"// Count the number of elements in the array",
							"pm.test(\"Number of elements in the array is greater than 0\", function () {",
							"    var jsonArray = pm.response.json();",
							"    pm.expect(jsonArray).to.be.an('array');",
							"    pm.expect(jsonArray.length).to.be.above(0);",
							"});",
							"",
							"pm.test(\"Each element in the array has the required properties\", function () {",
							"    pm.response.json().forEach(function (certificate) {",
							"        pm.expect(certificate).to.have.property('id');",
							"        pm.expect(certificate).to.have.property('url');",
							"        pm.expect(certificate).to.have.property('subject');",
							"        pm.expect(certificate).to.have.property('issuer');",
							"        pm.expect(certificate).to.have.property('validFrom');",
							"        pm.expect(certificate).to.have.property('validTo');",
							"    });",
							"});",
							"",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/all",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"all"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add twitter",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"first_page\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('twitter'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add short url",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('page_short_url'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add long url",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('page_long_url'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add too long url",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"page_too_long\");\r",
							"\r",
							"pm.test(\"Response status code is 400\", function () {\r",
							"    pm.response.to.have.status(400);\r",
							"});\r",
							"\r",
							"// pm.test(\"Response message: URL label is too long\", function () {\r",
							"//     pm.response.to\r",
							"// })"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('page_too_long'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				},
				"description": "[Reference for url lengths](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#url-length)"
			},
			"response": []
		},
		{
			"name": "Add too short url",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"page_too_long\");\r",
							"\r",
							"pm.test(\"Response status code is 400\", function () {\r",
							"    pm.response.to.have.status(400);\r",
							"});\r",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('page_too_long'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				},
				"description": "[Reference for url lengths](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#url-length)"
			},
			"response": []
		},
		{
			"name": "Add public GoC url",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\", pm.collectionVariables.get('public_goc_url'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add private GoC url Copy",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\",pm.collectionVariables.get('private_goc_url') );"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add google IPv4",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set('url', \"https://8.8.8.8\");"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add duplicate",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 303\", function () {\r",
							"    pm.response.to.have.status(303);\r",
							"});\r",
							"",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set(\"url\",pm.collectionVariables.get('private_goc_url') );"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add google",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();\r",
							"const url = pm.collectionVariables.get(\"url\");\r",
							"\r",
							"pm.test(\"Response status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"\r",
							"pm.test(\"Id is a non-zero integer\", function () {\r",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");\r",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is a non-empty string\", function () {\r",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"URL is \" + url, function () {\r",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);\r",
							"})\r",
							"\r",
							"pm.test(\"Subject is a non-empty string\", function () {\r",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Issuer is a non-empty string\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");\r",
							"});\r",
							"\r",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {\r",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");\r",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");\r",
							"});\r",
							"\r",
							"pm.test(\"ValidFrom is in the past\", function () {\r",
							"    var validFromDate = new Date(responseData.validFrom);\r",
							"    var currentDate = new Date();\r",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set('url', pm.collectionVariables.get('first_page'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Add thestar",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();",
							"const url = pm.collectionVariables.get(\"url\");",
							"",
							"pm.test(\"Response status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Id is a non-zero integer\", function () {",
							"  pm.expect(responseData.id).to.exist.and.to.be.a('number', \"Id should be a number\");",
							"  pm.expect(responseData.id).to.be.above(0, \"Id should be a non-zero integer\");",
							"});",
							"",
							"pm.test(\"URL is a non-empty string\", function () {",
							"  pm.expect(responseData.url).to.be.a('string').and.to.have.lengthOf.at.least(1, \"URL should not be empty\");",
							"});",
							"",
							"pm.test(\"URL is \" + url, function () {",
							"  pm.expect(responseData.url).to.be.equal(url, \"URL should be \" + url);",
							"})",
							"",
							"pm.test(\"Subject is a non-empty string\", function () {",
							"    pm.expect(responseData.subject).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Subject should not be empty\");",
							"});",
							"",
							"pm.test(\"Issuer is a non-empty string\", function () {",
							"    const responseData = pm.response.json();",
							"    pm.expect(responseData.issuer).to.be.a('string').and.to.have.lengthOf.at.least(1, \"Value should not be empty\");",
							"});",
							"",
							"pm.test(\"Valid date format for validFrom and validTo\", function () {",
							"    pm.expect(responseData.validFrom).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidFrom should be in the format YYYY-MM-DD\");",
							"    pm.expect(responseData.validTo).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}\\+\\d{2}\\:\\d{2}/, \"ValidTo should be in the format YYYY-MM-DD\");",
							"});",
							"",
							"pm.test(\"ValidFrom is in the past\", function () {",
							"    var validFromDate = new Date(responseData.validFrom);",
							"    var currentDate = new Date();",
							"    pm.expect(validFromDate).to.be.lessThan(currentDate, \"ValidFrom should be in the past\");",
							"});",
							"",
							"pm.collectionVariables.set(\"secondID\", responseData.id);",
							"pm.test(\"secondID set in Collection Variables\", function () {",
							"    pm.expect(pm.collectionVariables.get(\"secondID\")).to.be.equal(responseData.id);",
							"})"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.collectionVariables.set('url', pm.collectionVariables.get('second_page'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"protocolProfileBehavior": {
				"disabledSystemHeaders": {
					"content-type": true
				}
			},
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"url\" : \"{{url}}\"\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/add",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"add"
					]
				}
			},
			"response": []
		},
		{
			"name": "Get All after addition",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"var jsonArray = pm.response.json();\r",
							"var first_page = pm.collectionVariables.get(\"first_page\");\r",
							"var second_page = pm. collectionVariables.get(\"second_page\");\r",
							"// Check the last element in the Json\r",
							"pm.test(\"Last element in the array is \" + second_page, function () {\r",
							"    var lastElement = jsonArray[jsonArray.length - 1];\r",
							"    pm.expect(lastElement.url).to.exist.and.to.equal(second_page);\r",
							"});\r",
							"\r",
							"// Check the second last element in the Json\r",
							"pm.test(\"Second last element in the array is \" + first_page , function () {\r",
							"    var secondLastElement = jsonArray[jsonArray.length - 2];\r",
							"    pm.expect(secondLastElement.url).to.exist.and.to.equal(first_page);\r",
							"})\r",
							"\r",
							"//Check if private goc url is present, should be false outside of VPN\r",
							"pm.test(\"Check if Private GoC URL is in the array, should fail outside of VPN\", function () {\r",
							"    var isPrivateGocUrlPresent = jsonArray.some(function (item) {\r",
							"        return item.url === pm.variables.get(\"private_goc_url\");\r",
							"    });\r",
							"    pm.expect(isPrivateGocUrlPresent).to.be.true;\r",
							"});\r",
							"\r",
							"//Check if public goc url is present\r",
							"pm.test(\"Check if Publc GoC URL is in the array\", function () {\r",
							"    var isPublicGocUrlPresent = jsonArray.some(function (item) {\r",
							"        return item.url === pm.variables.get(\"public_goc_url\");\r",
							"    });\r",
							"    pm.expect(isPublicGocUrlPresent).to.be.true;\r",
							"});\r",
							"\r",
							"// Check if each element in the response has a unique URL\r",
							"pm.test(\"Each element in the response has a unique URL\", function() {\r",
							"    var urls = jsonArray.map(function(item) {\r",
							"        return item.url;\r",
							"    });\r",
							"    var uniqueUrls = new Set(urls);\r",
							"    pm.expect(uniqueUrls.size).to.equal(jsonArray.length);\r",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/all",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"all"
					]
				}
			},
			"response": []
		},
		{
			"name": "Delete non-existent cert",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.environment.set('certificatesID',0);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 404\", function () {",
							"    pm.response.to.have.status(404);",
							"});",
							"",
							"pm.test(\"Error is 'Certificate not Found'\", function () {",
							"    pm.expect(pm.response.json().error).to.equal(\"Certificate not Found\");",
							"});",
							"",
							"pm.test(\"Message is 'Certificate with ID 0 not found'\", function () {",
							"    pm.expect(pm.response.json().message).to.equal(\"Certificate with ID \" + pm.environment.get(\"certificatesID\")+\" not found\");",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/delete/{{certificatesID}}",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"delete",
						"{{certificatesID}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Delete first cert",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.environment.set('certificatesID',1);\r",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 204\", function () {\r",
							"    pm.response.to.have.status(204);\r",
							"});\r",
							"\r",
							"pm.collectionVariables.set('deletedID', pm.environment.get('certificateID'));"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/delete/{{certificatesID}}",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"delete",
						"{{certificatesID}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Delete first cert again",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.environment.set('certificatesID',1);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"const responseData = pm.response.json();",
							"",
							"",
							"pm.test(\"Response status code is 404\", function () {",
							"    pm.expect(pm.response.code).to.equal(404);",
							"});",
							"",
							"",
							"pm.test(\"Validate 'status' field is present in the response\", function () {  ",
							"  pm.expect(responseData).to.have.property('status');",
							"});",
							"",
							"",
							"pm.test(\"The 'error' field should be empty\", function () {",
							"  pm.expect(responseData.error).to.equal('Certificate not Found');",
							"});",
							"",
							"",
							"pm.test(\"The 'message' field should be empty\", function () {",
							"    pm.expect(responseData.message).to.equal(\"Certificate with ID \" + pm.environment.get(\"certificatesID\")+ \" not found\");",
							"});",
							"",
							"",
							"pm.test(\"Response time is less than 200ms\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(200);",
							"});",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "DELETE",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/delete/{{certificatesID}}",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"delete",
						"{{certificatesID}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "Check if deleted cert is gone",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"var jsonArray = pm.response.json();\r",
							"var deletedID = pm.collectionVariables.get('deletedID');\r",
							"\r",
							"// Check if any result has id deletedid\r",
							"pm.test(\"Check if deleted record has been removed\", function() {\r",
							"    var hasDeletedId = jsonArray.some(function(item) {\r",
							"        return item.id === deletedID;\r",
							"    });\r",
							"    pm.expect(hasDeletedId).to.be.false;\r",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{PROTOCOL}}://{{HOST}}/api/certificates/all",
					"protocol": "{{PROTOCOL}}",
					"host": [
						"{{HOST}}"
					],
					"path": [
						"api",
						"certificates",
						"all"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "first_page",
			"value": "https://www.google.com",
			"type": "string"
		},
		{
			"key": "second_page",
			"value": "https://www.thestar.com",
			"type": "string"
		},
		{
			"key": "secondID",
			"value": ""
		},
		{
			"key": "page_long_url",
			"value": "https://llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.co.uk/",
			"type": "string"
		},
		{
			"key": "page_short_url",
			"value": "https://be.com",
			"type": "string"
		},
		{
			"key": "url",
			"value": "",
			"type": "string"
		},
		{
			"key": "private_goc_url\n",
			"value": "https://jill.hc-sc.gc.ca",
			"type": "string"
		},
		{
			"key": "public_goc_url",
			"value": "https://www.hc-sc.gc.ca",
			"type": "string"
		},
		{
			"key": "twitter",
			"value": "https://www.twitter.com",
			"type": "string"
		},
		{
			"key": "page_too_short",
			"value": "https://.ca",
			"type": "string"
		},
		{
			"key": "page_too_long",
			"value": "https://llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch123123123.co.uk/",
			"type": "string"
		},
		{
			"key": "previousID",
			"value": "",
			"type": "string"
		},
		{
			"key": "deletedID",
			"value": "",
			"type": "string"
		}
	]
}